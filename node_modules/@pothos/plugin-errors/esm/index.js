import './global-types.js';
import SchemaBuilder, { BasePlugin, PothosSchemaError, sortClasses, typeBrandKey, unwrapOutputFieldType } from '@pothos/core';
export * from './types.js';
const pluginName = "errors";
export default pluginName;
export function capitalize(s) {
    return `${s.slice(0, 1).toUpperCase()}${s.slice(1)}`;
}
export const defaultGetResultName = ({ parentTypeName, fieldName }) => `${parentTypeName}${fieldName}Success`;
export const defaultGetUnionName = ({ parentTypeName, fieldName }) => `${parentTypeName}${fieldName}Result`;
export const unwrapError = Symbol.for("Pothos.unwrapErrors");
function createErrorProxy(target, ref, state) {
    return new Proxy(target, {
        get(err, val, receiver) {
            if (val === unwrapError) {
                return () => {
                    // eslint-disable-next-line no-param-reassign
                    state.wrapped = false;
                };
            }
            if (val === typeBrandKey) {
                return ref;
            }
            return Reflect.get(err, val, receiver);
        },
        getPrototypeOf(err) {
            const proto = Reflect.getPrototypeOf(err);
            if (!state.wrapped || !proto) {
                return proto;
            }
            return createErrorProxy(proto, ref, state);
        }
    });
}
const errorTypeMap = new WeakMap();
export class PothosErrorsPlugin extends BasePlugin {
    wrapIsTypeOf(isTypeOf, config) {
        if (isTypeOf) {
            return (parent, context, info) => {
                if (typeof parent === "object" && parent) {
                    var _parent_unwrapError;
                    (_parent_unwrapError = parent[unwrapError]) === null || _parent_unwrapError === void 0 ? void 0 : _parent_unwrapError.call(parent);
                }
                return isTypeOf(parent, context, info);
            };
        }
        return isTypeOf;
    }
    onOutputFieldConfig(fieldConfig) {
        const errorOptions = fieldConfig.pothosOptions.errors;
        const errorBuilderOptions = this.builder.options.errorOptions;
        if (!errorOptions) {
            return fieldConfig;
        }
        var _errorBuilderOptions_defaultResultOptions;
        const { name: getResultName = defaultGetResultName, ...defaultResultOptions } = (_errorBuilderOptions_defaultResultOptions = errorBuilderOptions === null || errorBuilderOptions === void 0 ? void 0 : errorBuilderOptions.defaultResultOptions) !== null && _errorBuilderOptions_defaultResultOptions !== void 0 ? _errorBuilderOptions_defaultResultOptions : {
            name: defaultGetResultName
        };
        var _errorBuilderOptions_defaultUnionOptions;
        const { name: getUnionName = defaultGetUnionName, ...defaultUnionOptions } = (_errorBuilderOptions_defaultUnionOptions = errorBuilderOptions === null || errorBuilderOptions === void 0 ? void 0 : errorBuilderOptions.defaultUnionOptions) !== null && _errorBuilderOptions_defaultUnionOptions !== void 0 ? _errorBuilderOptions_defaultUnionOptions : {
            name: defaultGetUnionName
        };
        const parentTypeName = this.buildCache.getTypeConfig(fieldConfig.parentType).name;
        const { types = [], result: { name: resultName = getResultName({
            parentTypeName,
            fieldName: capitalize(fieldConfig.name)
        }), fields: resultFieldOptions, ...resultObjectOptions } = {}, union: { name: unionName = getUnionName({
            parentTypeName,
            fieldName: capitalize(fieldConfig.name)
        }), ...unionOptions } = {}, dataField: { name: dataFieldName = "data", ...dataField } = {} } = errorOptions;
        var _errorBuilderOptions_defaultTypes;
        const errorTypes = sortClasses([
            ...new Set([
                ...types,
                ...(_errorBuilderOptions_defaultTypes = errorBuilderOptions === null || errorBuilderOptions === void 0 ? void 0 : errorBuilderOptions.defaultTypes) !== null && _errorBuilderOptions_defaultTypes !== void 0 ? _errorBuilderOptions_defaultTypes : []
            ])
        ]);
        var _errorOptions_directResult, _ref;
        const directResult = (_ref = (_errorOptions_directResult = errorOptions.directResult) !== null && _errorOptions_directResult !== void 0 ? _errorOptions_directResult : errorBuilderOptions === null || errorBuilderOptions === void 0 ? void 0 : errorBuilderOptions.directResult) !== null && _ref !== void 0 ? _ref : false;
        const typeRef = unwrapOutputFieldType(fieldConfig.type);
        const typeName = this.builder.configStore.getTypeConfig(typeRef).name;
        const unionType = this.runUnique(resultName, () => {
            var _this_buildCache_getTypeConfig_extensions;
            let resultType;
            if (directResult && !Array.isArray(fieldConfig.pothosOptions.type)) {
                resultType = fieldConfig.pothosOptions.type;
                const resultConfig = this.builder.configStore.getTypeConfig(resultType);
                if (resultConfig.graphqlKind !== "Object") {
                    throw new PothosSchemaError(`Field ${parentTypeName}.${fieldConfig.name} must return an ObjectType when 'directResult' is set to true`);
                }
            }
            else {
                resultType = this.builder.objectRef(resultName);
                resultType.implement({
                    ...defaultResultOptions,
                    ...resultObjectOptions,
                    fields: (t) => {
                        return {
                            ...resultFieldOptions === null || resultFieldOptions === void 0 ? void 0 : resultFieldOptions(t),
                            [dataFieldName]: t.field({
                                ...dataField,
                                type: fieldConfig.pothosOptions.type,
                                nullable: fieldConfig.type.kind === "List" ? {
                                    items: fieldConfig.type.type.nullable,
                                    list: false
                                } : false,
                                resolve: (data) => data
                            })
                        };
                    }
                });
            }
            const getDataloader = (_this_buildCache_getTypeConfig_extensions = this.buildCache.getTypeConfig(unwrapOutputFieldType(fieldConfig.type)).extensions) === null || _this_buildCache_getTypeConfig_extensions === void 0 ? void 0 : _this_buildCache_getTypeConfig_extensions.getDataloader;
            var _errorTypeMap_get;
            return this.builder.unionType(unionName, {
                types: [
                    ...errorTypes,
                    resultType
                ],
                resolveType: (obj) => (_errorTypeMap_get = errorTypeMap.get(obj)) !== null && _errorTypeMap_get !== void 0 ? _errorTypeMap_get : resultType,
                ...defaultUnionOptions,
                ...unionOptions,
                extensions: {
                    ...unionOptions.extensions,
                    getDataloader,
                    pothosPrismaIndirectInclude: {
                        getType: () => typeName,
                        path: directResult ? [] : [
                            {
                                type: resultName,
                                name: dataFieldName
                            }
                        ]
                    }
                }
            });
        });
        return {
            ...fieldConfig,
            extensions: {
                ...fieldConfig.extensions,
                pothosErrors: errorTypes
            },
            type: {
                kind: "Union",
                ref: unionType,
                nullable: fieldConfig.type.nullable
            }
        };
    }
    wrapResolve(resolver, fieldConfig) {
        var _fieldConfig_extensions;
        const pothosErrors = (_fieldConfig_extensions = fieldConfig.extensions) === null || _fieldConfig_extensions === void 0 ? void 0 : _fieldConfig_extensions.pothosErrors;
        if (!pothosErrors) {
            return resolver;
        }
        return async (...args) => {
            try {
                return await resolver(...args);
            }
            catch (error) {
                for (const errorType of pothosErrors) {
                    if (error instanceof errorType) {
                        const result = createErrorProxy(error, errorType, {
                            wrapped: true
                        });
                        errorTypeMap.set(result, errorType);
                        return result;
                    }
                }
                throw error;
            }
        };
    }
}
SchemaBuilder.registerPlugin(pluginName, PothosErrorsPlugin);
//# sourceMappingURL=index.js.map
